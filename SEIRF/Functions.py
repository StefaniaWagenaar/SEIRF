# -*- coding: utf-8 -*-
"""
Created on Tue Sep 17 16:36:04 2024

@author: 6408885
"""

"""
WRITTEN BY STEFANIA WAGENAAR

This file contains all the functions needed for the visualisation and 
computation of the properties of the SEIRF.


"""

import cartopy.crs as ccrs
import numpy as np
from matplotlib.patches import Polygon
from pmagpy import pmag,ipmag,pmagplotlib
import geoTools
import pygplates
import pandas as pd
from optimised_rotation_updater import OptimisedRotationUpdater

def ellipse_from_kent(kent_dic):
    """
    Function that takes a kent dictionary and returns the parameters needed
    to construct an uncertainty ellipse
    """
    
    mean_lon = kent_dic['dec']
    mean_lat = kent_dic['inc']
    
    if mean_lon > 180:
        mean_lon = mean_lon-360
        
    zdec = kent_dic['Zdec']
    zinc = kent_dic['Zinc']
        
    if zdec > 180:
        zdec = zdec-360
    
    km,degrees,bearing = geoTools.haversine(zdec,zinc,mean_lon,mean_lat)
    
    l1 = kent_dic['Zeta']*111
    l2 = kent_dic['Eta']*111

    return [l1,l2,bearing,mean_lon,mean_lat]



def plot_pole_ellipse(map_axis, dictionary, 
                      color='k', edgecolor='k', marker='s', 
                      markersize=20, label='', alpha=1.0, lw=1, lower=True, zorder=100
                      , filled=False, transform=None, **kwargs):
    """
    Adapted from the ipmagpy source code to include filled ellipses
    
    Plot a mean pole confidence ellipse associated with a Kent distribution

    Parameters:
        map_axis : the name of the current map axis that has been developed using cartopy
        dictionary : a dictionary generated by the pmag.dobingham or pmag.dokent functions
        color : symbol color; the default color is black. Other colors can be chosen (e.g. 'r')
        marker : the default marker is a circle. Other symbols can be chosen (e.g. 's')
        markersize : the default is 20. Other size can be chosen
        label : the default is no label. Labels can be assigned.
        legend : the default is no legend ('no'). Putting 'yes' will plot a legend.
        filled_pole : if True, the A95 ellipse will be filled with color
        fill_color : color of fill; the default is black.
        fill_alpha : transparency of filled ellipse (the default is 1.0; no transparency).
        lower : hemisphere to plot the ellipse when calling function pmagplotlib.plot_ell (default is True)
        zorder : plotting order (default is 100; higher will move to top of plot) 

    Examples:
        >>> kent_dict = {'dec': 287.53798364307437,
                    'inc': 88.56067392991959,
                    'n': 5,
                    'Zdec': 54.83073632264832,
                    'Zinc': 0.8721861867684042,
                    'Edec': 144.84816793561657,
                    'Einc': 1.1448791390804505,
                    'Zeta': 4.640345964184263,
                    'Eta': 6.8378968512569465,
                    'R1': 0.9914595207919079,
                    'R2': 0.006259515780690272}
        >>> map_axis = ipmag.make_orthographic_map(central_longitude=200,central_latitude=90)
        >>> ipmag.plot_pole_ellipse(map_axis,kent_dict, color='red',markersize=40)
    """
    
    if transform == None:
        transform=ccrs.PlateCarree()
    
    
    pars = []
    pars.append(dictionary['dec'])
    pars.append(dictionary['inc'])
    pars.append(dictionary['Zeta'])
    pars.append(dictionary['Zdec'])
    pars.append(dictionary['Zinc'])
    pars.append(dictionary['Eta'])
    pars.append(dictionary['Edec'])
    pars.append(dictionary['Einc'])

    map_axis.scatter(dictionary['dec'], dictionary['inc'], marker=marker,
                     color=color, edgecolors=edgecolor, s=markersize,
                     label=label, transform=ccrs.PlateCarree(), zorder=zorder)

    fignum=1
    ellipse_points = np.array(pmagplotlib.plot_ell(fignum, pars, lower=lower, plot=False)).T
    map_axis.plot(ellipse_points[0], ellipse_points[1], color=color,
                 transform=ccrs.Geodetic(), alpha=alpha, lw=lw, 
                     zorder=zorder)
    
    
    
    if filled:
        ellip = np.array((ellipse_points[0], ellipse_points[1])).T
        ellip = map_axis.projection.transform_points(
            transform, ellip[:, 0], ellip[:, 1])
        poly = Polygon(ellip[:, :2],alpha=alpha,zorder=zorder,**kwargs)
        map_axis.add_patch(poly)
    
    return map_axis

def plume_migration(hs_dataframe, model_name, iteration, rot_file_inputdir, include_chains,rot_file_folder):
    


    rotation_file_name = rot_file_inputdir +'/'+ rot_file_folder + '/optimised_rotation_model_' + rot_file_folder + str(iteration) + 'test.rot'

    rotation_model = pygplates.RotationModel(rotation_file_name)

    
    hs_dataframe = pd.read_csv('C:/Users/6408885/optAPM-master/optAPM-master/data/Hotspots_steffi.csv',sep=';')
    

    
    trails_list = hs_dataframe
    

    all_trails = include_chains
    
    output = []

    
    for trail in all_trails:
        trail_df = trails_list.loc[trails_list['Chain'] == trail]
        trail_df = trail_df.reset_index(drop=True)
        
        trail_ref = (trail_df.iloc[0]['ref_lat'],trail_df.iloc[0]['ref_lon'])
        
        trail_ids = trail_df['Plateid']
        
        
        ages = np.array(trail_df['Age'])
        
        
        for n,time in enumerate(ages):
            
            trail_id = trail_ids[n]
            errors = np.array(trail_df.Error)
            err = errors[n]
            
            max_age = time+err
            min_age = time-err
            
            times = [min_age,time,max_age]
            
            point_lat = np.array(trail_df.Lat)[n]
            point_lon = np.array(trail_df.Lon)[n]
            
            lats = []
            lons = []
            
            for moment in times:
                #rotation = rotation_model.get_rotation(0, trail_id,from_time=moment)
                rotation = rotation_model.get_rotation(moment, trail_id,from_time=0)
                
                #print(moment)
                
                # if ang_diff == False:
                
                lat_pole0 = [point_lat]
                lon_pole0 = [point_lon]
                    
                # if ang_diff == True:

                #     lat_pole0 = [19]
                #     lon_pole0 = [-155]
                
                lat, lon, angle = rotation.get_lat_lon_euler_pole_and_angle_degrees()
                #print( lat, lon, angle)
                
                lat_c,lon_c = geoTools.checkLatLon(lat, lon)
                
                
                #angle = -angle
                
                    
                euler_pole = [lat_c,lon_c,angle]
                euler_pole = list([euler_pole[0],euler_pole[1],euler_pole[2]])

                
                pole = pmag.pt_rot(euler_pole,lat_pole0,lon_pole0)

                
                lats.append(np.float64(pole[0])[0])
                lons.append(np.float64(pole[1])[0])
            

            
            
            output.append({'Chain': trail, 'plateid': trail_id, 'Age': time, 'min_age': min_age, 'max_age': max_age, 'ref_lat': trail_ref[0], 'ref_lon': trail_ref[1],
                           'loc_lat': lats[1], 'loc_lon': lons[1],
                           'min_loc_lat': lats[0],'min_loc_lon': lons[0],
                           'max_loc_lat': lats[2],'max_loc_lon': lons[2]})
            
            

    output = pd.DataFrame(output)
    
    ages_int = np.arange(10,140,10)
    
    output2 = []
    
    for trail in all_trails:
        output_chain = output.loc[output['Chain'] == trail]
        output_chain = output_chain.reset_index(drop=True)
        
        for time in ages_int:
            
            #output_time = output_chain.loc[output_chain['Age']]
            for i in range(1,len(output_chain)):
                
                if output_chain['Age'][i] >= time and output_chain['Age'][i-1] <= time:
                    
                    min_lat = output_chain['loc_lat'][i-1] + ((output_chain['loc_lat'][i]-output_chain['loc_lat'][i-1]) * ((time - output_chain['min_age'][i-1]) / (output_chain['min_age'][i]-output_chain['min_age'][i-1])))
                    lat = output_chain['loc_lat'][i-1] + ((output_chain['loc_lat'][i]-output_chain['loc_lat'][i-1]) * ((time - output_chain['max_age'][i-1]) / (output_chain['max_age'][i]-output_chain['max_age'][i-1])))
                    max_lat = output_chain['loc_lat'][i-1] + ((output_chain['loc_lat'][i]-output_chain['loc_lat'][i-1]) * ((time - output_chain['Age'][i-1]) / (output_chain['Age'][i]-output_chain['Age'][i-1])))
                    
                    min_lon = output_chain['loc_lon'][i-1] + ((output_chain['loc_lon'][i]-output_chain['loc_lon'][i-1]) * ((time - output_chain['min_age'][i-1]) / (output_chain['min_age'][i]-output_chain['min_age'][i-1])))
                    lon = output_chain['loc_lon'][i-1] + ((output_chain['loc_lon'][i]-output_chain['loc_lon'][i-1]) * ((time - output_chain['max_age'][i-1]) / (output_chain['max_age'][i]-output_chain['max_age'][i-1])))
                    max_lon = output_chain['loc_lon'][i-1] + ((output_chain['loc_lon'][i]-output_chain['loc_lon'][i-1]) * ((time - output_chain['Age'][i-1]) / (output_chain['Age'][i]-output_chain['Age'][i-1])))
    
                    output2.append({'Chain': trail, 'Age': time, 'ref_lat': output_chain['ref_lat'][i], 'ref_lon': output_chain['ref_lon'][i],
                                   'loc_lat': lat, 'loc_lon': lon,
                                   'min_loc_lat': min_lat,'min_loc_lon': min_lon,
                                   'max_loc_lat': max_lat,'max_loc_lon': max_lon})
    
    return trails_list, output2

def get_reference_params(age):
    """
    Returns a 2-tuple containg reference plate ID and reference rotation filename (or None).
    
    If reference rotation filename is None then it means the no-net-rotation model should be used.
    """
    
    ref_rotation_file = '1000_0_rotfile_Merdith_et_al'
    
    if age <= 550:
        ref_rotation_plate_id = 701
    else:
        ref_rotation_plate_id = 101
   
    
    return ref_rotation_plate_id, ref_rotation_file

